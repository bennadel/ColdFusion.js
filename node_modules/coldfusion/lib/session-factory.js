
// Include core libraries.
var events = require( "events" );

// Include the timed cache constructor. Each session is going to
// be a specialized version of a timed cache.
var TimedCache = require( "./timed-cache" );


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I am a session constructor.
function Session( sessionID, timeout ){

	// Call the super constructor.
	TimedCache.call( this, timeout );

	// Store the unique session ID.
	this._sessionID = sessionID
	
}


// Extend the event emitter class.
Session.prototype = Object.create( TimedCache.prototype );


// I return the session's unique ID.
Session.prototype.getSessionID = function(){

	// Return the unique ID. 
	return( this._sessionID );
	
};


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I am the session factory constructor.
function SessionFactory(){

	// Call the super constructor.
	events.EventEmitter.call( this );
	
	var that = this;
	
	// I am an auto-incrementing ID. Each session identifier will
	// be based on this ID and a time-string.
	this._sessionIndex = 0;
	
	// I am the collection of active sessions. Each session will be
	// indexed by its sessionID. 
	this._sessions = {};
	
}


// Extend the event emitter class. This will allow us to use the 
// on() and emit() methods.
SessionFactory.prototype = Object.create( events.EventEmitter.prototype );


// I return a new unique session ID.
SessionFactory.prototype._getNewSessionID = function(){
		
	// Return an incremented / random session ID.
	return( "CFJS-" + ++this._sessionIndex + "-" + (new Date()).getTime() );
	
};

	
// I get the session based on the given ID.
SessionFactory.prototype.getSession = function( sessionID ){
	
	// Return the session. If it doesn't exist, this will return
	// null.
	return( this._sessions[ sessionID ] || null );
	
};
	
	
// I create and return a new session.
SessionFactory.prototype.newSession = function( timeout ){
	
	var that = this;
	
	// Create a new session instance.
	var session = new Session( this._getNewSessionID(), timeout );
	
	// Cache the session in the local collection.
	this._sessions[ session.getSessionID() ] = session;
	
	// Bind a one-time listener to the session for timeout. Once
	// the session times out once, the session factory does not
	// care about it any longer.
	session.once(
		"timeout",
		function(){

			// Delete the session from the active sessions.
			delete( that._sessions[ session.getSessionID() ] );
			
			// Emit the timeout event at the factory level and pass the
			// target session through.
			that.emit( "timeout", session );
			
		}
	);
	
	// Retuen the session instance.
	return( session );
	
};
	

// ---------------------------------------------------------- //
// ---------------------------------------------------------- //

// Create an instance of the session factory.
var sessionFactory = new SessionFactory();

// Export this session factory.
module.exports = sessionFactory;

