

// Include the evented-cache. The times cache is simple a sub-class
// of the evented cache which can timeout.
var EventedCache = require( "./evented-cache" );


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I am the timed cache constructor. This cache can only be idle 
// for the given timeout before it becomes invalidated (and emits 
// a "timeout" event. 
function TimedCache( timeout ){

	// Call the super constructor.
	EventedCache.call( this );
	
	var that = this;
	
	// Store the time at which the cache was created.
	this._started = (new Date().getTime());
	
	// Store the time at which the cache was last "touched".
	this._lastTouched = this._started;
	
	// I flag whether or not the cache is timed out.
	this._isTimedOut = false;
	
	// Store the timeout for the cache. This is the number of
	// milliseoncds that the cache can stay idle (not being touched)
	// before it times out.
	this._timeout = timeout;
		
	// I am the timeout timer. 
	this._timeoutTimer = setTimeout(
		function(){
			that._end();
		},
		this._timeout
	);

}


// Extend the evented cache class so that we can use set() and get() 
// functions in conjunction with timer-based invalidation.
TimedCache.prototype = Object.create( EventedCache.prototype );


// I timeout the cache.
TimedCache.prototype._end = function(){

	// Overwrite the touch method so that the timed-out cache cannot 
	// accidentally get started back-up again with a rogue object
	// reference.
	this.touch = function(){
		return( this );
	};

	// Flag the cache as timed out.
	this._isTimedOut = true;

	// Emit the timeout event.
	this.emit( "timeout" );
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I return whether or not the cache is timed out.
TimedCache.prototype.isTimedOut = function(){
	
	// Return the timeout flag.
	return( this._isTimedOut );
	
};


// I touch the cache, breaking its idle time. I can also accept a new 
// timeout value (as the cache timeout can be changed at any time).
TimedCache.prototype.touch = function( newTimeout ){
	
	var that = this;

	// Clear any timer.
	clearTimeout( this._timeoutTimer );

	// Store the last touch date.
	this._lastTouched = (new Date()).getTime();

	// Store the new timeout (if provided).
	this._timeout = (newTimeout || this._timeout);
	
	// Set the new timer for our idle timeout.
	this._timeoutTimer = setTimeout(
		function(){
			that._end();
		},
		this._timeout
	);
	
	// Return this object reference for method chaining.
	return( this );
	
};


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// Since this class is meant to be extended, export the constructor.
module.exports = TimedCache;


