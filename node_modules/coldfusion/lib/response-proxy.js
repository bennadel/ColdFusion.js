
// Include core libraries.
var events = require( "events" );


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I am the response proxy constructor.
function ResponseProxy( response, cookies ){

	// Initialize super class properties. This will make sure that
	// two instances of the response proxy don't accidentally share
	// and event listeners.
	events.EventEmitter.call( this );
	
	var that = this;
	
	// Store the original response object.
	this._response = response;
	
	// Store the time at which the request started.
	this._started = (new Date().getTime());
	
	// Store the initial timeout. This is the number of milliseconds 
	// that the request can be held open until it is closed by the
	// request proxy itself. If the timeout is NULL, the request will
	// not timeout.
	this._timeout = null;
	
	// I am the timeout timer.
	this._timeoutTimer = null;
	
	// Store the cookies as public property.
	this.cookies = cookies;
	
	// Keep a collection of new cookies created in this request.
	this._outgoingCookies = [];
	
	// Keep a collection of cookies that are being deleted.
	this._expiringCookies = [];
	
	// Bind to the cookies set-event so we can add header values as
	// necesary.
	this.cookies.on(  
		"set",
		function( name, value ){	
			
			// Track the outgoing cookie.
			that._outgoingCookies.push({
				name: name,
				value: value
			});
			
		}
	);
	
	// Bind to the cookies remove-event so we can add header values
	// as necessary (for expiration).
	this.cookies.on(  
		"remove",
		function( name, value ){	
			
			// Track the outgoing cookie.
			that._expiringCookies.push({
				name: name,
				value: ""
			});
			
		}
	);

	
	// Set up the default status code.
	this._status = {
		code: 200,
		text: "OK"
	};
	
	// Set up the headers collection.
	this._headers = {};
	
	// Set the default headers.
	this.setHeader( "content-type", "text/plain" );
		
	// I determine whether or not the headers have been flushed.
	this._isCommitted = false;
		
	// Return this object reference.
	return( this );
	
}

// Extend the EventEmitter class allowing us to use on() and emit()
// methods like the underlying response.
ResponseProxy.prototype = new events.EventEmitter();


// I commit the response to the client. This will flush the headers 
// and flag the response as committed.
ResponseProxy.prototype._commitResponse = function(){

	// Raise the commit-start event - this will give people one last
	// hook for setting headers before they are flushed.
	this.emit( "commitStart" );

	// Flag the response as committed.
	this._isCommitted = true;

	// Build up the cookies name=value array.
	var cookiePairs = [];

	// Check to see if we need to add any outoing cookies header.
	if (this._outgoingCookies.length){

		// Add each name/value cookie pair to the array.
		this._outgoingCookies.forEach(
			function( pair ){

				cookiePairs.push( pair.name + "=" + escape( pair.value ) );
				
			}
		);
		
	}
	
	// Check to see if we need to add any expiring cookie headers.
	if (this._expiringCookies.length){

		// Add each name/value cookie pair to the array.
		this._expiringCookies.forEach(
			function( pair ){

				cookiePairs.push( pair.name + "=" + escape( pair.value ) + "; expires=" + (new Date()) + ";" );
				
			}
		);

	}
	
	// Check to see if there is already a set-cookie header. If so, then
	// simply push it onto the current pair collection.
	if ("set-cookie" in this._headers){
		
		// Append the existing set value.
		cookiePairs.push( this._headers[ "set-cookie" ] );

	}
	
	// Check to see if we have any cookie pairs to write to the head.
	if (cookiePairs.length){

		// Add the cookie values to the header.
		this._response.setHeader( "set-cookie", cookiePairs );

	}
	
	// Write the status code.
	this._response.writeHead(
		this._status.code,
		this._status.text,
		this._headers
	);
	
	// Raise the commit-end event. At this point, no one can write
	// anymore headers to the response. 
	this.emit( "commitEnd" );

	// Raise the response-start event. This will be the first 
	// opporunity for someone to write to the output.
	this.emit( "responseStart" );

};


// I end the current response, flushing any headers and additional 
// content that have not yet been committed.
ResponseProxy.prototype.end = function( data, encoding ){

	// Because the end() function closes the underlying response, it's only
	// going to be meaningful on the first call. Let's override the public end()
	// method so that any subsequent calls to this proxy will be, for all intents
	// and purposes, ignored.
	this.end = function(){
		return( this );
	};

	// Clear any current timer.
	clearTimeout( this._timeoutTimer );

	// Check to see if the current response has been committed.
	// If not, then we have to commit before we end the response.
	if (!this._isCommitted){

		// Commit the response.
		this._commitResponse();

	}
	
	// Check to see if any data was send with the end() request.
	// If so, we want to write it manually - this way, we can still
	// put a hook around the underlying end() request.
	if (data){
		
		// Write the last piece of data.
		this._response.write( data, encoding );

	}
	
	// Raise the response-end event. This will provide one last 
	// hook for content to be written to the response.
	this.emit( "responseEnd" );
	
	// End the event.
	this._response.end();
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I provide access to the underlying response.
ResponseProxy.prototype.getResponse = function(){
	
	// Return the underlying response.
	return( this._response );
	
};


// I provide insight as to whether or not the response has been
// committed (ie. that the headers have been flushed).
ResponseProxy.prototype.isCommitted = function(){
	
	// Return the underlying flag.
	return( this._isCommitted );
	
};


// I add the given header name/value pair to the header collection.
ResponseProxy.prototype.setHeader = function( name, value ){
	
	// Store the header.
	this._headers[ String( name ).toLowerCase() ] = value;
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I set the given status code and text.
ResponseProxy.prototype.setStatus = function( code, text ){
	
	// Set the status code.
	this._status.code = code;
	this._status.text = (text || "");
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I update the request timeout.
ResponseProxy.prototype.setTimeout = function( timeout ){

	var that = this;

	// Clear any current timer.
	clearTimeout( this._timeoutTimer );
	
	// Set the new timeout.
	this._timeout = timeout;
	
	// Figure out how long we are going to leave the timer on before
	// we force the request to end.
	var delay = Math.max(
		this._timeout - ((new Date()).getTime() - this._started),
		10
	);
	
	// Set up a timer to end the request.
	this._timeoutTimer = setTimeout(
		function(){
			
			// Emit the timeout event.
			that.emit( "timeout" );

			// End the request.
			that.end();
			
		},
		delay
	);
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I write data to the response, flushing any headers that have not
// yet been committed.
ResponseProxy.prototype.write = function( data, encoding ){
	
	// Check to see if the current response has been committed.
	// If not, then we have to commit before we write.
	if (!this._isCommitted){

		// Commit the response.
		this._commitResponse();

	}
	
	// Write the data to the underlying response.
	this._response.write( data, encoding );
	
	// Return this object reference for method chaining.
	return( this );
	
};


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// Export an instance factory.
exports.newInstance = function( response, cookies ){

	// Return a new intsance.
	return( new ResponseProxy( response, cookies ) );
	
};

