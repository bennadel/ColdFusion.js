
// Include core libraries.
var events = require( "events" );


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I am the response proxy constructor.
function ResponseProxy( response, cookies ){

	// Initialize super class properties. This will make sure that
	// two instances of the response proxy don't accidentally share
	// and event listeners.
	events.EventEmitter.call( this );
	
	var that = this;
	
	// Store the original response object.
	this._response = response;
	
	// Store the time at which the request started.
	this._started = (new Date().getTime());
	
	// Store the initial timeout. This is the number of milliseconds 
	// that the request can be held open until it is closed by the
	// request proxy itself.
	this._timeout = null;
	
	// I am the timeout timer.
	this._timeoutTimer = null;
	
	// Store the cookies as public property.
	this.cookies = cookies;
	
	// Keep a collection of new cookies created in this request.
	this._outgoingCookies = [];
	
	// Bind to the cookies set-event so we can add header values as
	// necesary.
	this.cookies.on(  
		"set",
		function( name, value ){		
			// Track the outgoing cookie.
			that._outgoingCookies.push({
				name: name,
				value: value
			});
		}
	);
	
	// TODO: Figure out how to handle DELETE cookie values. Will need to 
	// flush expiration date for header.
	
	// Set up the default status code.
	this._status = {
		code: 200,
		text: "OK"
	};
	
	// Set up the default headers collection.
	this._headers = {
		"content-type": "text/plain"
	};
	
	// I determine whether or not the headers have been flushed.
	this._isCommitted = false;
	
	// Return this object reference.
	return( this );
	
}

// Extend the EventEmitter class allowing us to use on() and emit()
// methods like the underlying response.
ResponseProxy.prototype = new events.EventEmitter();


// I commit the response to the client. This will flush the headers 
// and flag the response as committed.
ResponseProxy.prototype._commitResponse = function(){

	// Raise the commit-start event - this will give people one last
	// hook for setting headers before they are flushed.
	this.emit( "commitStart" );

	// Flag the response as committed.
	this._isCommitted = true;

	// Check to see if we need to add any outoing cookies header.
	if (this._outgoingCookies.length){

		// Serialize the cookie string.
		var cookieString = this._outgoingCookies.reduce(
			function( cookieString, cookie ){
				return(
					cookieString + cookie.name + "=" + escape( cookie.value ) + ";"
				);
			},
			""
		);
		
		// Check to see if there is already a Set-Cookie header.
		this._headers[ "Set-Cookie" ] = (
			cookieString + 
			(this._headers[ "Set-Cookie" ] || "")
		);
		
	}
	
	// Write the status code.
	this._response.writeHead(
		this._status.code,
		this._status.text,
		this._headers
	);
	
	// Raise the commit-end event. At this point, no one can write
	// anymore headers to the response. 
	this.emit( "commitEnd" );

	// Raise the response-start event. This will be the first 
	// opporunity for someone to write to the output.
	this.emit( "responseStart" );

};


// I end the current response, flushing any headers and additional 
// content that have not yet been committed.
ResponseProxy.prototype.end = function( data, encoding ){

	// Clear any current timer.
	clearTimeout( this._timeoutTimer );

	// Check to see if the current response has been committed.
	// If not, then we have to commit before we end the response.
	if (!this._isCommitted){

		// Commit the response.
		this._commitResponse();

	}
	
	// Check to see if any data was send with the end() request.
	// If so, we want to write it manually - this way, we can still
	// put a hook around the underlying end() request.
	if (data){
		
		// Write the last piece of data.
		this._response.write( data, encoding );

	}
	
	// Raise the response-end event. This will provide one last 
	// hook for content to be written to the response.
	this.emit( "responseEnd" );
	
	// End the event.
	this._response.end();
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I provide access to the underlying response.
ResponseProxy.prototype.getResponse = function(){
	
	// Return the underlying response.
	return( this._response );
	
};


// I add the given header name/value pair to the header collection.
ResponseProxy.prototype.setHeader = function( name, value ){
	
	// Store the header.
	this._headers[ name ] = value;
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I set the given status code and text.
ResponseProxy.prototype.setStatus = function( code, text ){
	
	// Set the status code.
	this._status.code = code;
	this._status.text = (text || "");
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I update the request timeout.
ResponseProxy.prototype.setTimeout = function( timeoutInSeconds ){
	var that = this;

	// Clear any current timer.
	clearTimeout( this._timeoutTimer );
	
	// Set the new timeout.
	this._timeout = (timeoutInSeconds * 1000);
	
	// Figure out how long we are going to leave the timer on before
	// we force the request to end.
	var delay = Math.max(
		this._timeout - ((new Date()).getTime() - this._started),
		10
	);
	
	// Set up a timer to end the request.
	this._timeoutTimer = setTimeout(
		function(){
			// End the request.
			that.end();
		},
		delay
	);
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I write data to the response, flushing any headers that have not
// yet been committed.
ResponseProxy.prototype.write = function( data, encoding ){
	
	// Check to see if the current response has been committed.
	// If not, then we have to commit before we write.
	if (!this._isCommitted){

		// Commit the response.
		this._commitResponse();

	}
	
	// Write the data to the underlying response.
	this._response.write( data, encoding );
	
	// Return this object reference for method chaining.
	return( this );
	
};


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// Export an instance factory.
exports.newInstance = function( response, cookies ){

	// Return a new intsance.
	return( new ResponseProxy( response, cookies ) );
	
};

