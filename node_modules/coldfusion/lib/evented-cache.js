
// Include core libraries.
var events = require( "events" );


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I am the evented cache constructor. I store key/value pairs, and
// emit events whenever they local cache is mutated.
function EventedCache(){

	// Call the super constructor.
	events.EventEmitter.call( this );
	
	// I am the cache of values being stored.
	this._cache = {};
	
	// I am the collection of values added as implicit getter / setters.
	// We need to keep track of these so that when the value gets removed,
	// we'll know if we need to remove the implicit getter / setter.
	this._getterSetters = {};
	
}


// Extend the event emitter class so that we can use on() and emit() 
// in conjunction with cache-based mutations.
EventedCache.prototype = Object.create( events.EventEmitter.prototype );


// I clear the local cache.
EventedCache.prototype.clear = function(){
	
	// Loop over the object to remove each key individually. This will allow
	// a "remove" event to be emitted for each key in the current cache.
	for (var key in this._cache){

		// Remove the key.
		this.remove( key );

	}
	
	// Emit the clear event.
	this.emit( "clear" );

	// Return this object reference for method chaining.
	return( this );
	
};


// I get the value at the given key. If no value exists, an optional 
// default value can be returned.
EventedCache.prototype.get = function( name, defaultValue ){
	
	// Check to see if the name exists in the local cache.
	if (name in this._cache){
		
		// Return the currently stored value.
		return( this._cache[ name ] );

	} else {

		// Return the default value (if it was provided) or null.
		return( (arguments.length == 2) ? defaultValue : null );
	
	}
	
};


// I get all the values in the local cache.
EventedCache.prototype.getAll = function(){

	// Create a new transport object for our values. We don't want to 
	// pass back the underlying cache value as that breaks our 
	// layer of encapsulation.
	var transport = {};
	
	// Loop over each key and transfer it to the transport object.
	for (var key in this._cache){

		// Copy key/value pair over.
		transport[ key ] = this._cache[ key ];

	}

	// Return the collection.
	return( transport );
	
};


// I remove any value at the given name.
EventedCache.prototype.remove = function( name ){
	
	// Check to see if the given name even exists in the local cache.
	if (name in this._cache){
		
		// Get the current value.
		var value = this._cache[ name ];
		
		// Delete the cache entry.
		delete( this._cache[ name ] );
		
		// Delete any implicit getter / setter we created.
		this._removeGetterSetter( name );
		
		// Emit the remove event.
		this.emit( "remove", name, value );

	}
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I try to remove the implicit getter / setter properties.
EventedCache.prototype._removeGetterSetter = function( name ){
	
	// Before we delete anything, make sure that the given property
	// was added as a getter / setter.
	if (!(name in this._getterSetters)){

		// Return out - this property was not added as a getter / setter.
		// We don't want to run the risk of deleting a critical value.
		return;

	}
	
	// Delete the getter / setter.
	delete( this[ name ] );
	
	// Delete the tracking of this value.
	delete( this._getterSetters[ name ] );
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I set the value at the given name.
EventedCache.prototype.set = function( name, value ){
	
	// Store the value in the local cache.
	this._cache[ name ] = value;
	
	// Try to add an implicit getter / setter for this value.
	this._setGetterSetter( name );
	
	// Emit the set event.
	this.emit( "set", name, value );
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I try to add the implicit getter / setter properties.
EventedCache.prototype._setGetterSetter = function( name ){
	
	var that = this;
	
	// If the property already exists on the object (whether as a 
	// getter/setter or a different value), we do not want to 
	// overwrite it. 
	if (name in this){

		// Return out - we can't add the getter / setter.
		return;

	}
	
	// Define the implicit getter.
	this.__defineGetter__(
		name,
		function(){
			return( that.get( name ) );
		}
	);
	
	// Define the implicit setter.
	this.__defineSetter__(
		name,
		function( value ){
			return( that.set( name, value ) );
		}
	);
	
	// Keep track of the getter / setter.
	this._getterSetters[ name ] = true;
	
	// Return this object reference for method chaining.
	return( this );
	
};


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// Since this class is meant to be extended, export the constructor.
module.exports = EventedCache;
