
// Include core libraries.
var events = require( "events" );


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I am the evented cache constructor. I store key/value pairs, and
// emit events whenever they local cache is mutated.
function EventedCache(){

	// Call the super constructor.
	events.EventEmitter.call( this );
	
	// I am the cache of values being stored.
	this._cache = {};

}


// Extend the event emitter class so that we can use on() and emit() 
// in conjunction with cache-based mutations.
EventedCache.prototype = Object.create( events.EventEmitter.prototype );


// I clear the local cache.
EventedCache.prototype.clear = function(){
	
	// Get the old cache reference.
	var oldCache = this._cache;
	
	// Create a new cache instance.
	this._cache = {};

	// Emit the clear event.
	this.emit( "clear" );

	// Loop over the cache elements to delete them. The hope is that 
	// this will help with garbage collection?????
	for (var key in oldCache){

		// Delete the entry.
		delete( oldCache[ key ] );

	}

	// Return this object reference for method chaining.
	return( this );
	
};


// I get the value at the given key. If no value exists, an optional 
// default value can be returned.
EventedCache.prototype.get = function( name, defaultValue ){
	
	// Check to see if the name exists in the local cache.
	if (name in this._cache){
		
		// Return the currently stored value.
		return( this._cache[ name ] );

	} else {

		// Return the default value (if it was provided) or null.
		return( (arguments.length == 2) ? defaultValue : null );
	
	}
	
};


// I get all the values in the local cache.
EventedCache.prototype.getAll = function(){

	// Create a new transport object for our values. We don't want to 
	// pass back the underlying cache value as that breaks our 
	// layer of encapsulation.
	var transport = {};
	
	// Loop over each key and transfer it to the transport object.
	for (var key in this._cache){

		// Copy key/value pair over.
		transport[ key ] = this._cache[ key ];

	}

	// Return the collection.
	return( transport );
	
};


// I remove any value at the given name.
EventedCache.prototype.remove = function( name ){
	
	// Check to see if the given name even exists in the local cache.
	if (name in this._cache){
		
		// Get the current value.
		var value = this._cache[ name ];
		
		// Delete the cache entry.
		delete( this._cache[ name ] );
		
		// Emit the remove event.
		this.emit( "remove", name, value );

	}
	
	// Return this object reference for method chaining.
	return( this );
	
};


// I set the value at the given name.
EventedCache.prototype.set = function( name, value ){
	
	// Store the value in the local cache.
	this._cache[ name ] = value;
	
	// Emit the set event.
	this.emit( "set", name, value );
	
	// Return this object reference for method chaining.
	return( this );
	
};


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// Since this class is meant to be extended, export the constructor.
module.exports = EventedCache;
