
// Include the application factory - this handles the storage and creation
// of new application instances.
var applicationFactory = require( "./lib/application-factory" );

// Include the session factory - this handles the storage and creation
// of new session instances. 
var sessionFactory = require( "./lib/session-factory" );


// I am the most recent configuration instance that has been created. 
// I am used for the "end" events (onSessionEnd / onApplicationEnd).
var mostRecentRequestConfig = null;

// These are just some short-hand notations to make the configuration
// easier to read.
var oneSecond = 1;
var oneMinute = (60 * oneSecond);
var oneHour = (60 * oneMinute);
var oneDay = (24 * oneHour);

// I define the configuration setting defaults for the user-provided 
// request configuration object (the Application.js file).
var requestConfigDefaults = {

	// I am the name of the application.
	name: "_",
	
	// I am the number of seconds that application can sit idle before 
	// it times out (4 hours). 
	applicationTimeout: (4 * oneHour),
	
	// I determine whether or not session management will be turned on. 
	sessionManagement: false,
	
	// I am the numver of seconds that the session can sit idle before 
	// it times out (30 minutes).
	sessionTimeout: (30 * oneMinute),
	
	// I determine if the session cookies should be set automatically.
	setClientCookies: true,
	
	// I determine the sessionID for the current request. By default, this
	// is detemrined by the incoming sessionID cookie; however, if the user
	// has chosen to set the cookies manually, this sessionID will also 
	// have to be set manually.
	sessionID: null,
	
	// I am the number of seconds that the application should run before
	// it times out (and is forceably closed).
	requestTimeout: (10 * oneSecond)
	
};


// Handle any errors that are not caught by local application-specific
// logic. 
process.on(
	"uncaughtException", 
	function( error ){

		// Since this error may have occurred during asynchronous processing,
		// we can't quite tell which request actually raised the exception.
		// As such, the best we can do at this point is pass the error off to
		// the most recently created Application.js instance.
		if (mostRecentRequestConfig){

			// Pass this off to event handler.
			return( onGlobalError( mostRecentRequestConfig, error ) );

		}
		
	}
);


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I handle the processing of each incoming HTTP request.
function handleRequest( request, response ){

	// Create a cookies scope for this request.
	var cookies = require( "./lib/cookies" ).newInstance(
		(request.headers.cookie || "")
	);
	
	// Create a new request proxy for this request.
	var requestProxy = require( "./lib/request-proxy" ).newInstance(
		request,
		cookies
	);
	
	// Create a response proxy for this request.
	var responseProxy = require( "./lib/response-proxy" ).newInstance( 
		response,
		cookies
	);
	
	
	// Create our request configuration object. A new config instance will 
	// be created for every single page request.
	var requestConfig = {};
	
	// Use the root Application.js function to initialize the request
	// configuration for this request.
	require( process.cwd() + "/Application" ).call( 
		requestConfig, 
		requestProxy, 
		responseProxy 
	);
	
	// Sanitize and flesh out the request-based configuration with the defaults.
	// This will allow all of our logic to be a lot easier going forward (as we
	// process the various events).
	for (var configKey in requestConfigDefaults){
		
		// Check to see if this key is in the current request config.
		if ((configKey in requestConfig) == false){
			
			// Store the default into the request config.
			requestConfig[ configKey ] = requestConfigDefaults[ configKey ];
			
		}

	}
	
	// Store this request configuration as the most recent request configuration.
	// This will be used for asynchronous events like onApplicationEnd() and 
	// onSessionEnd().
	mostRecentRequestConfig = requestConfig;
	
	
	// Bind to the response end event so we can wire up our onRequestEnd() 
	// event handler.
	responseProxy.once(
		"responseEnd",
		function(){

			// Pass this off to the event handler.
			return( onRequestEnd( requestConfig, requestProxy, responseProxy ) );
			
		}
	);
		
	// Check to see if the request configuration has defined a request 
	// timeout (in seconds). By default, the request will never timeout 
	// until the response is explicitly closed.
	if ("requestTimeout" in requestConfig){

		// Bind to the timeout event.
		responseProxy.once(
			"timeout",
			function(){
				
				// Pass this off to the event handler.
				return( onError( requestConfig, new Error( "timeout" ), requestProxy, responseProxy ) );
				
			}
		);

		// Set the request timeout (convert the seconds to milliseconds).
		responseProxy.setTimeout( requestConfig.requestTimeout * 1000 );
	
	}
	
	// Now, start passing the request through the processing pipeline.
	return( onApplicationStart( requestConfig, requestProxy, responseProxy ) );

}


// I initialize the application.
function onApplicationStart( config, request, response ){

	// Define the application name.
	var applicationName = config.name;
	
	// Define the application timeout (translate it from seconds - how it
	// is provided in the config - to milliseconds).
	var applicationTimeout = (config.applicationTimeout * 1000);

	// Try to get the associated application.
	var application = applicationFactory.getApplication( applicationName );

	// Check to see if the application was found. If so, then there is 
	// no more application-based logic that we need to handle.
	if (application){

		// Touch the application to end its idle time. When doing this,
		// pass in any updated application timeout that may have been set
		// for this request.
		application.touch( applicationTimeout );

		// Store the application with the current request.
		request.application = application;
		
		// Pass the processing onto the next event.
		return( onSessionStart( config, request, response ) );

	}

	// If there was no application, then this is either the first 
	// request or the previous application has timed-out. In either case,
	// we need to create a new application instance.
	var application = applicationFactory.newApplication( applicationName, applicationTimeout );
	
	// Associate the application with the current request.
	request.application = application;
	
	// Bind to the timeout on the application.
	application.once(
		"timeout",
		function(){
			
			// Check to see if there is a current configuration instance. 
			// This only works if we have an instance to reference.
			if (mostRecentRequestConfig){
	
				// Hand this off to the event handler.
				return( onApplicationEnd( mostRecentRequestConfig, application ) );
				
			}

		}
	);
	
	// Check to see if the current request configuration instance has an
	// associated event handler.
	if ("onApplicationStart" in config){

		// Pass off the event handler to the request configuration instance.
		config.onApplicationStart(
			request,
			response,
			function( loadApplication ){

				// Check to see if we can let the rest of the application
				// load. If the callback passed-through an explicit false,
				// then we don't want the application to load.
				if (loadApplication == false){

					// We should not let the rest of the application load.
					return( response.end() );

				}

				// Hand off to the next event handler.
				return( onSessionStart( config, request, response ) );

			}
		);

	} else {

		// The request configuration does not have any specific event 
		// logic for this event - pass request off to the session event.
		return( onSessionStart( config, request, response ) );

	}

}


// I initialize the session.
function onSessionStart( config, request, response ){

	// Check to see if the current request configuration has session 
	// management enabled. If it doesn't then we can immediately pass 
	// the request off to the next event handler.
	if (!config.sessionManagement){

		// This request is not using session management.
		return( onRequestStart( config, request, response ) );

	}

	// Try to get the associated session. Each session is identified
	// by unique ID. First, we will check in the configuration file, then
	// in the cookies. 
	var session = sessionFactory.getSession(
		config.sessionID ||
		request.cookies.get( "sessionID" ) ||
		""
	);

	// Define the session timeout (translate it from seconds - how it is
	// provided in the configuration - to milliseconsd).
	var sessionTimeout = (config.sessionTimeout * 1000);

	// Check to see if the session was found. If so, then there is no 
	// more session-based logic that we need to handle.
	if (session){

		// Touch the session to end its idle time. When doing this,
		// pass in any updated session timeout that may have been set
		// for this request.
		session.touch( sessionTimeout );

		// Store the session with the current request.
		request.session = session;
		
		// Pass the processing onto the next event.
		return( onRequestStart( config, request, response ) );

	}
	
	// If there was no session, then we need to create one.
	var session = sessionFactory.newSession( sessionTimeout );
	
	// Get the application associated with this request (for our timeout binding).
	var application = request.application;
	
	// Associate the session with the current request.
	request.session = session;
	
	// Bind to the timeout on the session.
	session.once(
		"timeout",
		function(){
			
			// Check to see if there is a current configuration instance. 
			// This only works if we have an instance to reference.
			if (mostRecentRequestConfig){
	
				// Hand this off to the event handler.
				return( onSessionEnd( mostRecentRequestConfig, application, session ) );
				
			}

		}
	);
	
	// Check to see if we can set the outoing cookies. The user might
	// want to do this on their own in order to encrypt the cookie value.
	if (config.setClientCookies !== false){
		
		// Store the session ID in the outgoing cookies.
		response.cookies.set( "sessionID", session.getSessionID() );

	}

	// Check to see if the request configuration has an event handler 
	// for the session start event.
	if ("onSessionStart" in config){

		// Pass off the event handler to the request configuration instance.
		config.onSessionStart(
			request,
			response,
			function(){

				// Hand off to the next event handler.
				return( onRequestStart( config, request, response ) );
				
			}
		);

	} else {
	
		// Pass the processing off to the next event.
		return( onRequestStart( config, request, response ) );
	
	}

}


// I initialize the request.
function onRequestStart( config, request, response ){

	// Check to see if the request configuration instance has an event
	// handler for the request start event.
	if ("onRequestStart" in config){

		// Pass off the event handler to the request configuration instance.
		config.onRequestStart(
			request,
			response,
			function( loadRequest ){

				// Check to see if we can let the rest of the request
				// load. If the callback passed-through an explicit false,
				// then we don't want the request to load.
				if (loadRequest == false){
					
					// We should not let the rest of the request load.
					return( response.end() );

				}

				// Hand off to the next event handler.
				return( onRequest( config, request, response ) );

			}
		);

	} else {
	
		// Pass the processing off to the next event.
		return( onRequest( config, request, response ) );
	
	}
	
}


// I process the request.
function onRequest( config, request, response ){
	
	// Check to see if the request configuration instance has an 
	// event handler for the request processor event.
	if ("onRequest" in config){

		// Pass off the event handler to the request configuration instance.
		return( config.onRequest( request, response ) );

	} else {

		// End the request - this will trigger the request-end event.
		response.end();

	}

}


// I tear down the request.
function onRequestEnd( config, request, response ){
	
	// Check to see if the request configuration instance has an event 
	// handler for the request end event.
	if ("onRequestEnd" in config){

		// Pass off the event handler to the request configuration instance.
		return( config.onRequestEnd( request, response ) );

	}
	
}


// I tear down the session.
function onSessionEnd( config, applicationScope, sessionScope ){

	// Check to see if the request configuration instance has an event 
	// handler for the session end event.
	if ("onSessionEnd" in config){
		
		// Pass off the event handler to the request configuration instance.
		return( config.onSessionEnd( applicationScope, sessionScope ) );

	}

}


// I tear down the application.
function onApplicationEnd( config, applicationScope ){

	// Check to see if the request configuration instance has an event 
	// handler for the application end event.
	if ("onApplicationEnd" in config){
		
		// Pass off the event handler to the request configuration instance.
		return( config.onApplicationEnd( applicationScope ) );
		
	}

}


// I handle any uncaught errors in the application that have bubbled
// up to the server server AND can be associated with a specific request
// and response object.
function onError( config, error, request, response ){
	
	// Check to see if the request configuration instance has an event 
	// handler for the error event.
	if ("onError" in config){
		
		// Pass off the event handler to the request configuration instance.
		config.onError( error, request, response );

	}
	
}


// I handle any uncaught errors in the application that have bubbled
// all the way back up to the server. At this point, it's hard to 
// determine where an error actually occurred. Even our "request configuration"
// instance is a "best guess" instance.
function onGlobalError( config, error ){

	// Check to see if the request configuration instance has an event 
	// handler for the error event.
	if ("onError" in config){

		// Pass off the event handler to the request configuration instance. 
		// The response from the event handler will tell us how to proceed.
		var errorResponse = config.onError( error );
		
		// If the response is an explicit False, then the application is
		// deferring back to the server to  handle the error. Any other 
		// response dictates that the error has been handled by the app.
		if (errorResponse !== false){

			// The application has handled the error - do not kill 
			// the process.
			return;

		}

	}
	
	// If we made it this far, there is no app-level error handling.
	// Log the error and kill the process.
	console.log( "-----------------------------------------------------" );
	console.log( "-----------------------------------------------------" );
	console.log( new Date() );
	console.log( ">> Unhandled Exception" );	
	console.log( ">>>> Type :: " + error.type );
	console.log( ">>>> Message :: " + error.message );
	console.log( ">>>> Stack :: \n" + error.stack );
	console.log( "-----------------------------------------------------" );
	console.log( "-----------------------------------------------------" );
	
	// Exit with an error. Give the exit a slight delay so that the log()
	// method has time to finish flushing to the terminal. Otherwise, our
	// error message will not be fully accessible.
	//
	// NOTE: Using process.nextTick() does not provide enough time for the
	// error to be fully flushed to the output. We had to fall back on the 
	// setTimeout() function.
	setTimeout(
		function(){
			process.exit( 1 );
		}, 
		50
	);
	
}


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// Export or a start function to start the ColdFusion server.
exports.start = function( portNumber ){

	// Create the HTTP server. This server does not represent our 
	// "ColdFusion" application - it merely facilitates the mapping
	// of incoming HTTP request to our code base.
	var server = require( "http" ).createServer( handleRequest );
	
	// Default the port number.
	portNumber = (portNumber || 8080);

	// Point the server to listen to the given port for incoming
	// requests.
	server.listen( portNumber );
	
	// Log the server start.
	console.log( "ColdFusion.js server listening on port " + portNumber );

};

