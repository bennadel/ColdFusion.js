
// Include core libraries.
var http = require( "http" );


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// Creat the application scope. For now, this will just be an instance
// of the evented cache.
var applicationScope = new require( "./lib/evented-cache" );


// Include the session factory - this handles the storage and creation
// of new session instances. 
var sessionFactory = require( "./lib/session-factory" );

// Bind to the session timeout.
sessionFactory.on( 
	"timeout",
	function( session ){

		// Check to see if there is a current application instance. This
		// only works if we have an app to reference.
		if (mostRecentApplication){

			// Hand this off to the event handler.
			onSessionEnd( mostRecentApplication, applicationScope, session );
			
		}
		
	} 
);


// I am the most recent application instance that has been created. I 
// am used for the "end" events (onSessionEnd / onApplicationEnd).
var mostRecentApplication = null;


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I handle the processing of each incoming HTTP request.
function handleRequest( request, response ){

	// Create a cookies scope for this request.
	var cookies = require( "./lib/cookies" ).newInstance(
		(request.headers.cookie || "")
	);
	
	// Create a new request proxy for this request.
	var requestProxy = require( "./lib/request-proxy" ).newInstance(
		request,
		cookies
	);
	
	// Create a response proxy for this request.
	var responseProxy = require( "./lib/response-proxy" ).newInstance( 
		response,
		cookies
	);
	
	
	// Create our application object. A new app instance will be 
	// created for every single page request.
	var app = {};
	
	// Use the root Application.js function to initialize the app 
	// for this page request.
	require( process.cwd() + "/Application" ).call( 
		app, 
		requestProxy, 
		responseProxy 
	);
	
	
	// Bind to the response end event so we can wire up our onRequestEnd() 
	// event handler.
	responseProxy.once(
		"responseEnd",
		function(){

			// Pass this off to the event handler.
			return( onRequestEnd( app, requestProxy, responseProxy ) );
			
		}
	);
		
	// Check to see if the application has defined a default request
	// timeout (in seconds).
	if ("requestTimeout" in app){

		responseProxy.setTimeout( app.requestTimeout );
	
	}
	
	// Now, start passing the request through the processing pipeline.
	return( onApplicationStart( app, requestProxy, responseProxy ) );

}


// I initialize the application.
function onApplicationStart( app, request, response ){

	// Check to see if there is a current app instance. 
	if (mostRecentApplication){

		// Store the most current application instance.
		mostRecentApplication = app;

		// Append the application scope to the request.
		request.application = applicationScope;
		
		// The application had already been initialized. As such, 
		// pass the controll flow through to the session event
		// handler for processing.
		return( onSessionStart( app, request, response ) );

	}

	// Check to see if the current application instance has an
	// associated event handler.
	if ("onApplicationStart" in app){

		// Pass off the event handler to the app instance.
		app.onApplicationStart(
			request,
			response,
			function( loadApplication ){

				// Check to see if we can let the rest of the application
				// load. If the callback passed-through an explicit false,
				// then we don't want the application to load.
				if (loadApplication !== false){

					// Store the most current application instance.
					mostRecentApplication = app;
					
					// Append the application scope to the request.
					request.application = applicationScope;
					
					// Hand off to the next event handler.
					return( onSessionStart( app, request, response ) );

				} else {

					// We should not let the rest of the application
					// load.
					return( request.end() );

				}

			}
		);

	} else {

		// Store the most current application instance.
		mostRecentApplication = app;
		
		// Append the application scope to the request.
		request.application = applicationScope;

		// The application does not have any specific event logic for
		// this event - pass request off to the session event.
		return( onSessionStart( app, request, response ) );

	}

}


// I initialize the session.
function onSessionStart( app, request, response ){

	// Check to see if the current request has session management enabled.
	// If it doesn't then we can just pass the request off to the next
	// event handler.
	if (!app.sessionManagement){

		// This request is not using session management.
		return( onRequestStart( app, request, response ) );

	}

	// Try to get the associated session event.
	var session = sessionFactory.getSession( request.cookies.get( "sessionID" ) || "" );

	// Define the session timeout.
	var sessionTimeout = ((app.sessionTimeout || (20 * 60)) * 1000);

	// Check to see if the session was found. If so, then there is no 
	// more session-based logic that we need to handle.
	if (session){

		// Touch the session to end its idle time. When doing this,
		// pass in any updated session timeout that may have been set
		// for this request.
		session.touch( sessionTimeout );

		// Store the session with the current request.
		request.session = session;
		
		// Pass the processing onto the next event.
		return( onRequestStart( app, request, response ) );

	}
	

	// If there was no session, then we need to create one.
	var session = sessionFactory.newSession( sessionTimeout );
	
	// Associate the session with the current request.
	request.session = session;
	
	// Check to see if we can set the outoing cookies. The user might
	// want to do this on their own in order to encrypt the cookie value.
	if (app.setClientCookies !== false){
		
		// Store the session ID in the outgoing cookies.
		response.cookies.set( "sessionID", session.getSessionID() );

	}

	// Check to see if the application has an event handler for
	// the session start.
	if ("onSessionStart" in app){

		// Pass off the event handler to the app instance.
		app.onSessionStart(
			request,
			response,
			function(){

				// Hand off to the next event handler.
				return( onRequestStart( app, request, response ) );
				
			}
		);

	} else {
	
		// Pass the processing off to the next event.
		return( onRequestStart( app, request, response ) );
	
	}

}


// I initialize the request.
function onRequestStart( app, request, response ){

	// Check to see if the application has an event handler for
	// the request start.
	if ("onRequestStart" in app){

		// Pass off the event handler to the app instance.
		app.onRequestStart(
			request,
			response,
			function( loadRequest ){

				// Check to see if we can let the rest of the request
				// load. If the callback passed-through an explicit false,
				// then we don't want the request to load.
				if (loadRequest !== false){
					
					// Hand off to the next event handler.
					return( onRequest( app, request, response ) );

				} else {

					// We should not let the rest of the request load.
					return( request.end() );

				}

			}
		);

	} else {
	
		// Pass the processing off to the next event.
		return( onRequest( app, request, response ) );
	
	}
	
}


// I process the request.
function onRequest( app, request, response ){
	
	// Check to see if the application has an event handler for
	// the request processor.
	if ("onRequest" in app){

		// Pass off the event handler to the app instance.
		return( app.onRequest( request, response ) );

	} else {

		// End the request - this will trigger the request-end event.
		response.end();

	}

}


// I tear down the request.
function onRequestEnd( app, request, response ){
	
	// Check to see if the application has an event handler for
	// the request end event.
	if ("onRequestEnd" in app){

		// Pass off the event handler to the app instance.
		return( app.onRequestEnd( request, response ) );

	}
	
}


// I tear down the session.
function onSessionEnd( app, applicationScope, sessionScope ){

	// Check to see if the application has an event handler for
	// the session end.
	if ("onSessionEnd" in app){
		
		// Pass off the event handler to the app instance.
		return( app.onSessionEnd( applicationScope, sessionScope ) );

	}

}


// I tear down the application.
function onApplicationEnd( app, applicationScope ){

	// Check to see if the application has an event handler for
	// the session end.
	if ("onApplicationEnd" in app){
		
		// Pass off the event handler to the app instance.
		return( app.onApplicationEnd( applicationScope ) );
		
	}

}


// I handle any uncaught errors in the application.
function onError( error, status, response ){

	// Something completely unxpected happened.
	console.log( "Unexpecter error:" );
	console.dir( error );
	
	// Check to see if the response is available.
	if (response){
	
		// Write error header.
		response.writeHead(
			status.code,
			{ "Content-Type": "text/html" }
		);
		
		// Kill the incoming request.
		response.end( "<h1>" + status.text + "</h1>" );
		
	}

}


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// Export or a start function to start the ColdFusion server.
exports.start = function( portNumber ){

	// Create the HTTP server. This server does not represent our 
	// "ColdFusion" application - it merely facilitates the mapping
	// of incoming HTTP request to our code base.
	var server = http.createServer( handleRequest );
	
	// Default the port number.
	portNumber = (portNumber || 8080);

	// Point the server to listen to the given port for incoming
	// requests.
	server.listen( portNumber );
	
	// Log the server start.
	console.log( "ColdFusion.js server listening on port " + portNumber );

};

