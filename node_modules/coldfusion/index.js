
// Creat the application scope. For now, this will just be an instance
// of the evented cache.
var applicationScope = new require( "./lib/evented-cache" );


// Include the session factory - this handles the storage and creation
// of new session instances. 
var sessionFactory = require( "./lib/session-factory" );

// Bind to the session timeout.
sessionFactory.on( 
	"timeout",
	function( session ){

		// Check to see if there is a current application instance. This
		// only works if we have an app to reference.
		if (mostRecentApplication){

			// Hand this off to the event handler.
			return( onSessionEnd( mostRecentApplication, applicationScope, session ) );
			
		}
		
	} 
);


// I am the most recent application instance that has been created. I 
// am used for the "end" events (onSessionEnd / onApplicationEnd).
var mostRecentApplication = null;


// I define the application setting defaults.
var applicationSettingDefaults = {

	// I am the name of the application.
	name: "_",
	
	// I am the number of seconds that application can sit idle before 
	// it times out. 
	applicationTimeout: (1 * 24 * 60 * 60),
	
	// I determine whether or not session management will be turned on. 
	sessionManagement: false,
	
	// I am teh numver of seconds that the session can sit idle before 
	// it times out.
	sessionTimeout: (30 * 60),
	
	// I determine if the session cookies should be set automatically.
	setClientCookies: true,
	
	// I am the number of seconds that the application should run before
	// it times out (and is forceably closed).
	requestTimeout: 10
	
};


// Handle any errors that are not caught by local application-specific
// logic. 
process.on(
	"uncaughtException", 
	function( error ){

		// Since this error may have occurred during asynchronous processing,
		// we can't quite tell which request actually raised the exception.
		// As such, the best we can do at this point is pass the error off to
		// the most recently created Application.js instance.
		if (mostRecentApplication){

			// Pass this off to event handler.
			return( onGlobalError( mostRecentApplication, error ) );

		}
		
	}
);


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// I handle the processing of each incoming HTTP request.
function handleRequest( request, response ){

	// Create a cookies scope for this request.
	var cookies = require( "./lib/cookies" ).newInstance(
		(request.headers.cookie || "")
	);
	
	// Create a new request proxy for this request.
	var requestProxy = require( "./lib/request-proxy" ).newInstance(
		request,
		cookies
	);
	
	// Create a response proxy for this request.
	var responseProxy = require( "./lib/response-proxy" ).newInstance( 
		response,
		cookies
	);
	
	
	// Create our application object. A new app instance will be 
	// created for every single page request.
	var app = {};
	
	// Use the root Application.js function to initialize the app 
	// for this page request.
	require( process.cwd() + "/Application" ).call( 
		app, 
		requestProxy, 
		responseProxy 
	);
	
	
	// Bind to the response end event so we can wire up our onRequestEnd() 
	// event handler.
	responseProxy.once(
		"responseEnd",
		function(){

			// Pass this off to the event handler.
			return( onRequestEnd( app, requestProxy, responseProxy ) );
			
		}
	);
		
	// Check to see if the application has defined a request timeout (in
	// seconds). By default, the request will never timeout until the 
	// response is explicitly closed.
	if ("requestTimeout" in app){

		// Bind to the timeout event.
		responseProxy.once(
			"timeout",
			function(){
				
				// Pass this off to the event handler.
				return( onError( app, new Error( "timeout" ), requestProxy, responseProxy ) );
				
			}
		);

		// Set the request timeout.
		responseProxy.setTimeout( app.requestTimeout );
	
	}
	
	// Now, start passing the request through the processing pipeline.
	return( onApplicationStart( app, requestProxy, responseProxy ) );

}


// I initialize the application.
function onApplicationStart( app, request, response ){

	// Check to see if there is a current app instance. 
	if (mostRecentApplication){

		// Store the most current application instance.
		mostRecentApplication = app;

		// Append the application scope to the request.
		request.application = applicationScope;
		
		// The application had already been initialized. As such, 
		// pass the controll flow through to the session event
		// handler for processing.
		return( onSessionStart( app, request, response ) );

	}

	// Check to see if the current application instance has an
	// associated event handler.
	if ("onApplicationStart" in app){

		// Pass off the event handler to the app instance.
		app.onApplicationStart(
			request,
			response,
			function( loadApplication ){

				// Check to see if we can let the rest of the application
				// load. If the callback passed-through an explicit false,
				// then we don't want the application to load.
				if (loadApplication !== false){

					// Store the most current application instance.
					mostRecentApplication = app;
					
					// Append the application scope to the request.
					request.application = applicationScope;
					
					// Hand off to the next event handler.
					return( onSessionStart( app, request, response ) );

				} else {

					// We should not let the rest of the application
					// load.
					return( request.end() );

				}

			}
		);

	} else {

		// Store the most current application instance.
		mostRecentApplication = app;
		
		// Append the application scope to the request.
		request.application = applicationScope;

		// The application does not have any specific event logic for
		// this event - pass request off to the session event.
		return( onSessionStart( app, request, response ) );

	}

}


// I initialize the session.
function onSessionStart( app, request, response ){

	// Check to see if the current request has session management enabled.
	// If it doesn't then we can just pass the request off to the next
	// event handler.
	if (!app.sessionManagement){

		// This request is not using session management.
		return( onRequestStart( app, request, response ) );

	}

	// Try to get the associated session event.
	var session = sessionFactory.getSession( request.cookies.get( "sessionID" ) || "" );

	// Define the session timeout.
	var sessionTimeout = ((app.sessionTimeout || (20 * 60)) * 1000);

	// Check to see if the session was found. If so, then there is no 
	// more session-based logic that we need to handle.
	if (session){

		// Touch the session to end its idle time. When doing this,
		// pass in any updated session timeout that may have been set
		// for this request.
		session.touch( sessionTimeout );

		// Store the session with the current request.
		request.session = session;
		
		// Pass the processing onto the next event.
		return( onRequestStart( app, request, response ) );

	}
	

	// If there was no session, then we need to create one.
	var session = sessionFactory.newSession( sessionTimeout );
	
	// Associate the session with the current request.
	request.session = session;
	
	// Check to see if we can set the outoing cookies. The user might
	// want to do this on their own in order to encrypt the cookie value.
	if (app.setClientCookies !== false){
		
		// Store the session ID in the outgoing cookies.
		response.cookies.set( "sessionID", session.getSessionID() );

	}

	// Check to see if the application has an event handler for
	// the session start.
	if ("onSessionStart" in app){

		// Pass off the event handler to the app instance.
		app.onSessionStart(
			request,
			response,
			function(){

				// Hand off to the next event handler.
				return( onRequestStart( app, request, response ) );
				
			}
		);

	} else {
	
		// Pass the processing off to the next event.
		return( onRequestStart( app, request, response ) );
	
	}

}


// I initialize the request.
function onRequestStart( app, request, response ){

	// Check to see if the application has an event handler for
	// the request start.
	if ("onRequestStart" in app){

		// Pass off the event handler to the app instance.
		app.onRequestStart(
			request,
			response,
			function( loadRequest ){

				// Check to see if we can let the rest of the request
				// load. If the callback passed-through an explicit false,
				// then we don't want the request to load.
				if (loadRequest !== false){
					
					// Hand off to the next event handler.
					return( onRequest( app, request, response ) );

				} else {

					// We should not let the rest of the request load.
					return( request.end() );

				}

			}
		);

	} else {
	
		// Pass the processing off to the next event.
		return( onRequest( app, request, response ) );
	
	}
	
}


// I process the request.
function onRequest( app, request, response ){
	
	// Check to see if the application has an event handler for
	// the request processor.
	if ("onRequest" in app){

		// Pass off the event handler to the app instance.
		return( app.onRequest( request, response ) );

	} else {

		// End the request - this will trigger the request-end event.
		response.end();

	}

}


// I tear down the request.
function onRequestEnd( app, request, response ){
	
	// Check to see if the application has an event handler for
	// the request end event.
	if ("onRequestEnd" in app){

		// Pass off the event handler to the app instance.
		return( app.onRequestEnd( request, response ) );

	}
	
}


// I tear down the session.
function onSessionEnd( app, applicationScope, sessionScope ){

	// Check to see if the application has an event handler for
	// the session end.
	if ("onSessionEnd" in app){
		
		// Pass off the event handler to the app instance.
		return( app.onSessionEnd( applicationScope, sessionScope ) );

	}

}


// I tear down the application.
function onApplicationEnd( app, applicationScope ){

	// Check to see if the application has an event handler for
	// the session end.
	if ("onApplicationEnd" in app){
		
		// Pass off the event handler to the app instance.
		return( app.onApplicationEnd( applicationScope ) );
		
	}

}


// I handle any uncaught errors in the application that have bubbled
// up to the server server AND can be associated with a specific request
// and response object.
function onError( app, error, request, response ){
	
	// Check to see if the application has an event handler for the
	// error event.
	if ("onError" in app){
		
		// Pass off the event handler to the app instance.
		app.onError( error, request, response );

	}

}


// I handle any uncaught errors in the application that have bubbled
// all the way back up to the server. At this point, it's hard to 
// determine where an error actually occurred. Even our "app" instance
// is a "best guess" instance.
function onGlobalError( app, error ){

	// Check to see if the application has an event handler for the
	// error event.
	if ("onError" in app){

		// Pass off the event handler to the app instance. The response
		// from the event handler will tell us how to proceed.
		var errorResponse = app.onError( error );
		
		// If the response is an explicit False, then the application is
		// deferring back to the server to  handle the error. Any other 
		// response dictates that the error has been handled by the app.
		if (errorResponse !== false){

			// The application has handled the error - do not kill 
			// the process.
			return;

		}

	}
	
	// If we made it this far, there is no app-level error handling.
	// Log the error and kill the process.
	console.log( "-----------------------------------------------------" );
	console.log( "-----------------------------------------------------" );
	console.log( new Date() );
	console.log( "Unhandled Exception" );	
	console.log( error.type );
	console.log( error.message );
	console.log( error.stack );
	console.log( "-----------------------------------------------------" );
	console.log( "-----------------------------------------------------" );
	
	// Exit with an error. Give the exit a slight delay so that the log()
	// method has time to finish flushing to the terminal. Otherwise, our
	// error message will not be fully accessible.
	//
	// NOTE: Using process.nextTick() does not provide enough time for the
	// error to be fully flushed to the output. We had to fall back on the 
	// setTimeout() function.
	setTimeout(
		function(){
			process.exit( 1 );
		}, 
		50
	);
	
}


// ---------------------------------------------------------- //
// ---------------------------------------------------------- //


// Export or a start function to start the ColdFusion server.
exports.start = function( portNumber ){

	// Create the HTTP server. This server does not represent our 
	// "ColdFusion" application - it merely facilitates the mapping
	// of incoming HTTP request to our code base.
	var server = require( "http" ).createServer( handleRequest );
	
	// Default the port number.
	portNumber = (portNumber || 8080);

	// Point the server to listen to the given port for incoming
	// requests.
	server.listen( portNumber );
	
	// Log the server start.
	console.log( "ColdFusion.js server listening on port " + portNumber );

};

